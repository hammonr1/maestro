<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chef Al Aire - Hand Cursor Prototype</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            color: #333333;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Full Screen Cursor */
        .hand-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            background-color: #ff4444;
            border: 2px solid #ffffff;
            border-radius: 50%;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(255, 68, 68, 0.4);
            transform: translate(-50%, -50%);
            transition: opacity 0.2s ease;
            opacity: 0;
        }

        .hand-cursor.visible {
            opacity: 1;
        }

        /* Debug Info Panel */
        .debug-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 9998;
            min-width: 250px;
        }

        .debug-row {
            margin: 5px 0;
        }

        .debug-label {
            color: #4CAF50;
            font-weight: bold;
        }

        /* Compact Video Feed */
        .video-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9997;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }

        #video {
            width: 200px;
            height: 150px;
            background-color: #000;
            display: block;
            transform: scaleX(-1); /* Flip video horizontally to mirror effect */
            -webkit-transform: scaleX(-1); /* Safari support */
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 200px;
            height: 150px;
            pointer-events: none;
        }

        /* Main Content Area */
        .container {
            text-align: center;
            max-width: 800px;
            width: 100%;
            margin: 0 auto;
            padding: 60px 20px 20px;
        }

        h1 {
            font-size: 36px;
            margin-bottom: 10px;
            color: #4CAF50;
        }

        .subtitle {
            font-size: 18px;
            color: #666666;
            margin-bottom: 40px;
        }

        .status {
            font-size: 18px;
            font-weight: bold;
            margin: 20px 0;
            padding: 10px 20px;
            border-radius: 5px;
            background-color: #ffffff;
            border: 2px solid #333;
            display: inline-block;
            min-width: 200px;
        }

        .status.initializing {
            color: #ffc107;
            border-color: #ffc107;
        }

        .status.camera-active {
            color: #2196F3;
            border-color: #2196F3;
        }

        .status.hand-detected {
            color: #4CAF50;
            border-color: #4CAF50;
        }

        .instructions {
            background-color: #ffffff;
            border-radius: 8px;
            padding: 30px;
            margin: 20px 0;
            font-size: 16px;
            text-align: left;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .instruction-title {
            color: #4CAF50;
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 15px;
        }

        .instruction-list {
            list-style: none;
            padding-left: 0;
        }

        .instruction-list li {
            margin: 10px 0;
            padding-left: 25px;
            position: relative;
        }

        .instruction-list li:before {
            content: "üëâ";
            position: absolute;
            left: 0;
        }

        .error-message {
            background-color: #f44336;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            display: none;
        }

        .fps-counter {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 5px 10px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <!-- Full Screen Hand Cursor -->
    <div class="hand-cursor" id="handCursor"></div>
    
    <!-- Debug Info Panel -->
    <div class="debug-panel">
        <div class="debug-row">
            <span class="debug-label">Phase:</span> 1B - Hand Cursor Control
        </div>
        <div class="debug-row" id="debugStatus">
            <span class="debug-label">Status:</span> Initializing...
        </div>
        <div class="debug-row" id="debugCursor">
            <span class="debug-label">Cursor:</span> Hidden
        </div>
        <div class="debug-row" id="debugCoords">
            <span class="debug-label">Screen Coords:</span> (---, ---)
        </div>
        <div class="debug-row" id="debugSmoothing">
            <span class="debug-label">Smoothing:</span> 0.3
        </div>
        <div class="debug-row" id="debugFPS">
            <span class="debug-label">FPS:</span> 0
        </div>
    </div>
    
    <!-- Compact Video Feed -->
    <div class="video-container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        <div class="fps-counter" id="fpsCounter">FPS: 0</div>
    </div>

    <div class="container">
        <h1>üñ±Ô∏è Chef Al Aire Hand Cursor</h1>
        <div class="subtitle">Phase 1B: Full-Screen Hand Tracking Cursor</div>
        
        <div class="status initializing" id="status">Initializing...</div>
        
        <div class="error-message" id="error"></div>
        
        <div class="instructions">
            <div class="instruction-title">How to Test the Hand Cursor:</div>
            <ul class="instruction-list">
                <li>Grant camera permission when prompted</li>
                <li>Show your hand to the camera (top-right corner)</li>
                <li>Watch the red cursor follow your index finger</li>
                <li>Move your hand to reach all corners of the screen</li>
                <li>Debug info appears in the top-left corner</li>
            </ul>
        </div>
    </div>

    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        class HandCursorTracker {
            constructor() {
                // Video and canvas elements
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // UI elements
                this.status = document.getElementById('status');
                this.errorElement = document.getElementById('error');
                this.fpsCounter = document.getElementById('fpsCounter');
                this.handCursor = document.getElementById('handCursor');
                
                // Debug elements
                this.debugStatus = document.getElementById('debugStatus');
                this.debugCursor = document.getElementById('debugCursor');
                this.debugCoords = document.getElementById('debugCoords');
                this.debugFPS = document.getElementById('debugFPS');
                
                // Performance tracking
                this.frameCount = 0;
                this.cursorFrameCount = 0;
                this.lastTime = performance.now();
                this.fps = 0;
                
                // MediaPipe setup
                this.hands = null;
                this.camera = null;
                
                // Cursor smoothing - hamoco-style
                this.smoothFactor = 0.3;
                this.currentCursorX = window.innerWidth / 2;
                this.currentCursorY = window.innerHeight / 2;
                this.targetCursorX = this.currentCursorX;
                this.targetCursorY = this.currentCursorY;
                
                this.init();
            }
            
            async init() {
                try {
                    this.updateDebugStatus('Initializing MediaPipe...');
                    await this.setupMediaPipe();
                    await this.setupCamera();
                    this.updateStatus('camera-active', 'Camera Active');
                    this.updateDebugStatus('Camera Active - Show hand');
                } catch (error) {
                    this.showError('Initialization failed: ' + error.message);
                    console.error('Initialization error:', error);
                }
            }
            
            setupMediaPipe() {
                return new Promise((resolve, reject) => {
                    try {
                        this.hands = new Hands({
                            locateFile: (file) => {
                                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                            }
                        });
                        
                        this.hands.setOptions({
                            maxNumHands: 1,
                            modelComplexity: 1,
                            minDetectionConfidence: 0.5,
                            minTrackingConfidence: 0.5
                        });
                        
                        this.hands.onResults(this.onResults.bind(this));
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                });
            }
            
            async setupCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: 640,
                            height: 480,
                            facingMode: 'user'
                        }
                    });
                    
                    this.video.srcObject = stream;
                    
                    return new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            this.video.play();
                            this.canvas.width = 200; // Compact size
                            this.canvas.height = 150;
                            
                            this.camera = new Camera(this.video, {
                                onFrame: async () => {
                                    await this.hands.send({image: this.video});
                                    this.updateFPS();
                                },
                                width: 640,
                                height: 480
                            });
                            
                            this.camera.start();
                            resolve();
                        };
                    });
                } catch (error) {
                    throw new Error('Camera access denied or not available');
                }
            }
            
            onResults(results) {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    this.updateStatus('hand-detected', 'Hand Detected - Cursor Active');
                    this.updateDebugStatus('Hand Detected');
                    
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // Draw hand landmarks (scaled for compact view)
                    this.drawHand(landmarks);
                    
                    // Update cursor position using hamoco-style mapping
                    this.updateCursor(landmarks);
                    
                } else {
                    this.updateStatus('camera-active', 'Camera Active - Show your hand');
                    this.updateDebugStatus('Camera Active - No hand');
                    this.hideCursor();
                }
                
                this.frameCount++;
            }
            
            updateCursor(landmarks) {
                // Get index finger tip (landmark 8) - hamoco approach
                const indexTip = landmarks[8];
                
                // MediaPipe gives normalized coordinates (0.0 to 1.0)
                // Map to full screen coordinates with FIXED mirror effect
                const normalizedX = indexTip.x; // 0.0 to 1.0
                const normalizedY = indexTip.y; // 0.0 to 1.0
                
                // Convert to screen pixels - FLIP X AXIS for natural movement
                this.targetCursorX = (1 - normalizedX) * window.innerWidth;  // ‚Üê Fixed: Flip X axis
                this.targetCursorY = normalizedY * window.innerHeight;       // ‚Üê Y stays same
                
                // Clamp coordinates to screen bounds
                this.targetCursorX = Math.max(0, Math.min(window.innerWidth, this.targetCursorX));
                this.targetCursorY = Math.max(0, Math.min(window.innerHeight, this.targetCursorY));
                
                // Apply smoothing (linear interpolation)
                this.currentCursorX += (this.targetCursorX - this.currentCursorX) * this.smoothFactor;
                this.currentCursorY += (this.targetCursorY - this.currentCursorY) * this.smoothFactor;
                
                // Update cursor position
                this.handCursor.style.left = Math.round(this.currentCursorX) + 'px';
                this.handCursor.style.top = Math.round(this.currentCursorY) + 'px';
                this.handCursor.classList.add('visible');
                
                // Update debug info
                this.updateDebugCursor('Visible');
                this.updateDebugCoords(Math.round(this.currentCursorX), Math.round(this.currentCursorY));
                
                // Console logging every 30 frames
                this.cursorFrameCount++;
                if (this.cursorFrameCount % 30 === 0) {
                    console.log(`Cursor at (${Math.round(this.currentCursorX)}, ${Math.round(this.currentCursorY)})`);
                }
            }
            
            hideCursor() {
                this.handCursor.classList.remove('visible');
                this.updateDebugCursor('Hidden');
                this.updateDebugCoords('---', '---');
            }
            
            drawHand(landmarks) {
                const ctx = this.ctx;
                const scaleX = this.canvas.width / 640;  // Scale for compact view
                const scaleY = this.canvas.height / 480;
                
                // Hand connections (simplified skeleton)
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4],      // Thumb
                    [0, 5], [5, 6], [6, 7], [7, 8],      // Index finger
                    [5, 9], [9, 10], [10, 11], [11, 12], // Middle finger
                    [9, 13], [13, 14], [14, 15], [15, 16], // Ring finger
                    [13, 17], [17, 18], [18, 19], [19, 20], // Pinky
                    [0, 17] // Palm
                ];
                
                // Draw connections
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                connections.forEach(([start, end]) => {
                    const startPoint = landmarks[start];
                    const endPoint = landmarks[end];
                    
                    ctx.moveTo(startPoint.x * this.canvas.width, startPoint.y * this.canvas.height);
                    ctx.lineTo(endPoint.x * this.canvas.width, endPoint.y * this.canvas.height);
                });
                
                ctx.stroke();
                
                // Draw landmarks
                ctx.fillStyle = '#ff4444';
                landmarks.forEach((landmark, index) => {
                    const x = landmark.x * this.canvas.width;
                    const y = landmark.y * this.canvas.height;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, index === 8 ? 4 : 2, 0, 2 * Math.PI); // Larger for index finger tip
                    ctx.fill();
                    
                    // Label index finger tip
                    if (index === 8) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '8px Arial';
                        ctx.fillText('INDEX', x + 5, y - 5);
                        ctx.fillStyle = '#ff4444';
                    }
                });
            }
            
            updateStatus(className, text) {
                this.status.className = `status ${className}`;
                this.status.textContent = text;
            }
            
            updateDebugStatus(text) {
                this.debugStatus.innerHTML = `<span class="debug-label">Status:</span> ${text}`;
            }
            
            updateDebugCursor(text) {
                this.debugCursor.innerHTML = `<span class="debug-label">Cursor:</span> ${text}`;
            }
            
            updateDebugCoords(x, y) {
                this.debugCoords.innerHTML = `<span class="debug-label">Screen Coords:</span> (${x}, ${y})`;
            }
            
            showError(message) {
                this.errorElement.textContent = message;
                this.errorElement.style.display = 'block';
                this.updateStatus('initializing', 'Error');
                this.updateDebugStatus('Error: ' + message);
            }
            
            updateFPS() {
                const now = performance.now();
                const delta = now - this.lastTime;
                
                if (delta >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / delta);
                    this.fpsCounter.textContent = `FPS: ${this.fps}`;
                    this.debugFPS.innerHTML = `<span class="debug-label">FPS:</span> ${this.fps}`;
                    this.frameCount = 0;
                    this.lastTime = now;
                }
            }
        }
        
        // Start the application when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new HandCursorTracker();
        });
        
        // Handle window resize for cursor bounds
        window.addEventListener('resize', () => {
            // Update cursor bounds when window resizes
        });
        
        // Handle camera permission errors gracefully
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
        });
    </script>
</body>
</html>
